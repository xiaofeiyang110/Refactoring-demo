# 认识代码的坏味道

##  什么是坏味道
* 一些迹象，它指出“这里有一个可以用重构解决的问题”。

## 坏味道列表

### 重复代码（Duplicated Code）

* 概念：在一个以上的地方有相同的程序结构

* 带来的问题
    * 违反了DRY（Don’t Repeat Yourself）原则
    * 业务调整需要修改多个地方，很容易漏掉。改不全，导致bug


* 现象和解决手段
    * 同一个类的两个函数含有相同的表达式
        * Extract Method (提炼函数)  
    * 两个互为兄弟的子类内含相同表达式
        * Extract Method (提炼函数) 
        * Pull Up Method (函数上移) 
        * 如果只有部分相同：Extract Method (提炼函数) 提取相同的部分，然后Form Template Method（塑造模版函数）
    * 有些函数以不同的算法做相同的事
        * Substitute Algorithm（替换算法）
    * 两个毫不相关的类出现重复代码
        * 对其中一个Extract Class（提炼类）。

### Long Method（过长函数）
* 概念：显而易见，程序长

* 带来的问题
    * 程序越长越难理解
    * 可能杂糅了太多的职责，违反职责单一

* 现象和解决手段
    * 需要以注释来说明点什么的时候、寻找注释。代码的注释通常表明了代码用途和实现手法之间的语义距离，提醒你可以将这段代码替换成一个函数
        * Extract Method (提炼函数) 
          > 大量的参数和临时变量会对函数提炼形成阻碍，因为在尝试Extract Method (提炼函数)的时候他们会被当中参数传递给新提炼出来的函数。导致可读性没有提升。
          > <br/> 对于这样的情况，可以使用Replace Temp with Query(以查询取代临时变量)。Introduce Parameter Object(引入参数对象)和Preserve Whole Object(保持对象完整)简化过长的参数列表
          > <br/> 如果这时仍然有太多临时变量和参数，可以使用Replace Method with Method Object(以函数对象取代函数)
    * 条件表达式
        * Decompose Conditional（分解条件表达式）
    * 循环
        * 循环和其内的代码提炼到一个独立函数中
#### 概述
* 寻找代码中的注释，他们通常表明了代码用途和实现手法之间的语义距离。
* 条件表达式和循环也是提炼的信号。
* 更好的函数名称是能表明函数做什么而不是怎么做。函数名称能够解释其用途

### Large Class(过大的类)

### Long Parameter List（过长参数列）

### Divergent Change (发散式变化)

* 现象：某个类经常因为不同的原因在不同的方向上发生变化
    * 比如有一个类，如果新加入一个数据库，我必须修改这三个函数，如果新出现一种金融工具，我必须修改这四个函数。那么此时也许将这个对象分成两个会更好。这样一来每个对象就可以只因一种变化而需要修改。
    > 换句话说，针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。
* 问题：职责不单一
  * 从上面变化的角度来看,A变化修改三个函数，B变化修改另外的四个函数，那么至少这个类有两种职责

### Shotgun Surgery(霰弹式修改)

* 现象：和Divergent Change(发散式变化)很像，但是恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改。
* 问题：类不够内聚

##### Divergent Change (发散式变化)和 Shotgun Surgery(霰弹式修改)
* Divergent Change (发散式变化)：一个类受多种变化的影响_职责不单一
* Shotgun Surgery(霰弹式修改)：一种变化引发多个类相应修改_类不够内聚
 > 整理代码，使"外界变化"和"需要修改的类"趋于一一对应

### Feature Envy（依恋情结）
* 现象：函数对某个类的兴趣高过对自己所处类的兴趣。具体来说就是数据。比如某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。
 > 比如现在比较流行的贫血模型是不是就是这种坏味道呢？
 > 对象技术：将数据和对数据的操作行为包装在一起。这个是不是更加接近DDD的领域模型
 
### Data Clumps（数据泥团）
* 成群结队
