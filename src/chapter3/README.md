# 认识代码的坏味道

##  什么是坏味道
* 一些迹象，它指出“这里有一个可以用重构解决的问题”。

## 坏味道列表

### 重复代码（Duplicated Code）

* 概念：在一个以上的地方有相同的程序结构

* 带来的问题
    * 违反了DRY（Don’t Repeat Yourself）原则
    * 业务调整需要修改多个地方，很容易漏掉。改不全，导致bug


* 现象和解决手段
    * 同一个类的两个函数含有相同的表达式
        * Extract Method (提炼函数)  
    * 两个互为兄弟的子类内含相同表达式
        * Extract Method (提炼函数) 
        * Pull Up Method (函数上移) 
        * 如果只有部分相同：Extract Method (提炼函数) 提取相同的部分，然后Form Template Method（塑造模版函数）
    * 有些函数以不同的算法做相同的事
        * Substitute Algorithm（替换算法）
    * 两个毫不相关的类出现重复代码
        * 对其中一个Extract Class（提炼类）。

### Long Method（过长函数）
* 概念：显而易见，程序长

* 带来的问题
    * 程序越长越难理解
    * 可能杂糅了太多的职责，违反职责单一

* 现象和解决手段
    * 需要以注释来说明点什么的时候、寻找注释。代码的注释通常表明了代码用途和实现手法之间的语义距离，提醒你可以将这段代码替换成一个函数
        * Extract Method (提炼函数) 
          > 大量的参数和临时变量会对函数提炼形成阻碍，因为在尝试Extract Method (提炼函数)的时候他们会被当中参数传递给新提炼出来的函数。导致可读性没有提升。
          > <br/> 对于这样的情况，可以使用Replace Temp with Query(以查询取代临时变量)。Introduce Parameter Object(引入参数对象)和Preserve Whole Object(保持对象完整)简化过长的参数列表
          > <br/> 如果这时仍然有太多临时变量和参数，可以使用Replace Method with Method Object(以函数对象取代函数)
    * 条件表达式
        * Decompose Conditional（分解条件表达式）
    * 循环
        * 循环和其内的代码提炼到一个独立函数中
#### 概述
* 寻找代码中的注释，他们通常表明了代码用途和实现手法之间的语义距离。
* 条件表达式和循环也是提炼的信号。
* 更好的函数名称是能表明函数做什么而不是怎么做。函数名称能够解释其用途

### Large Class(过大的类)

### Long Parameter List（过长参数列）
* 现象：函数的参数列表太长
 > 有了对象技术，你就不必把函数需要的所有东西都以参数传递给它了，只需要传给它足够的，让函数能从中获得自己需要的东西就行了

* 问题：
  * 太长的参数列难以理解，不易使用
  * 一旦需要更多数据，不得不修改函数

### Divergent Change (发散式变化)

* 现象：某个类经常因为不同的原因在不同的方向上发生变化
    * 比如有一个类，如果新加入一个数据库，我必须修改这三个函数，如果新出现一种金融工具，我必须修改这四个函数。那么此时也许将这个对象分成两个会更好。这样一来每个对象就可以只因一种变化而需要修改。
    > 换句话说，针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。
* 问题：职责不单一
  * 从上面变化的角度来看,A变化修改三个函数，B变化修改另外的四个函数，那么至少这个类有两种职责

### Shotgun Surgery(霰弹式修改)

* 现象：和Divergent Change(发散式变化)很像，但是恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改。
* 问题：类不够内聚

##### Divergent Change (发散式变化)和 Shotgun Surgery(霰弹式修改)
* Divergent Change (发散式变化)：一个类受多种变化的影响_职责不单一
* Shotgun Surgery(霰弹式修改)：一种变化引发多个类相应修改_不够内聚
 > 整理代码，使"外界变化"和"需要修改的类"趋于一一对应

### Feature Envy（依恋情结）
* 现象：函数对某个类的兴趣高过对自己所处类的兴趣。具体来说就是数据。比如某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。
 > 比如现在比较流行的贫血模型是不是就是这种坏味道呢？
 > 对象技术：将数据和对数据的操作行为包装在一起。这个是不是更加接近DDD的领域模型
 
### Data Clumps（数据泥团）
* 现象：总是绑定在一起出现的数据。
  * 有一个判断标准：如果删掉众多数据中的一项，其他数据不再有意义。这就是一个明确的信号。需要为它们产生一个新对象

### Primitive Obsession (基本类型偏执)
* 现象：有一组应该总是被放在一起的字段
 > 这个不就是数据泥团吗？和数据泥团有啥区别呢

### Switch Statements (switch 惊悚现身)
* 现象：switch语句
* 问题
  * 重复：同样的switch语句散布在不同地方
  * 违反开闭原则

### Parallel Inheritance Hierarchies(平行继续体系)
* 现象：某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同。
 > 前缀名称一致意味这对于某种变化，需要修改这两个继承体系也就是Shotgun Surgery(霰弹式修改)。所以它是Shotgun Surgery(霰弹式修改)的特殊情况

### Lazy Class (冗赘类)
* 现象：没有足够价值或工作的类

### Speculative Generality(夸夸其谈未来性)
* 现象：过度设计导致的一些用不到，没有价值的类。或者类的唯一用户是没有价值的测试用例。

### Temporary Field（令人迷惑的暂时字段）
* 现象：类中的某个实例变量仅为某种特定情况而设

### Message Chains(过度耦合的消息链)
* 现象：一个用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象......实际
