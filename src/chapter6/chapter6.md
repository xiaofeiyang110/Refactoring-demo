## 重新组织函数

### Extract Method (提炼函数)

* 现象
  * 过长函数或者一段需要注释才能让人理解用途的代码。
  > 函数长度不是主要问题，关键在于函数名称和函数本体之间的语义距离
  > 函数的粒度小，那么函数被复用的机会就更大，并且函数的覆写也会容易些。 

* 将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。

###### 做法

* 创造一个新函数，根据函数的意图对它命名（以它"做什么"来命名，而不是以它"怎么做"命名），新的函数名称要能够以更好方式昭示代码意图。
 > 如果你能想出一个更有意义的名称可以更好的昭示代码意图，那么即使你要提炼的代码很简单，你也要提炼它。否则就别动它
* 将提炼出来的代码从源函数复制到新建的目标函数中。

* 仔细检查提炼出来的代码，看看其中是否引用了"作用域限于源函数"的变量（包括局部变量和源函数参数）

* 检查是否有"仅用于被提炼代码段"的临时变量。如果有，在目标函数中将它们声明为临时变量。

* 检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，
并将结果赋值给相关变量。如果很难这么做，或如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动地提炼出来。你可能需要先使用
Split Temporary Variable(分解临时变量)。然后再尝试提炼。也可以使用Replace Temp with Query (以查询取代临时变量)，将临时变量消灭掉。

* 将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。

* 处理完所有局部变量之后，进行编译。

* 在源函数中，将被提炼代码段替换为对目标函数的调用。

> 如果你将任何临时变量移动到目标函数中，请检查它们原本的声明式是否在被提炼代码段的外围。如果是，现在你可以删除这些声明式了。

* 编译，测试。
##### 几种情况总结
* 无局部变量的情况比较简单
* 有局部变量-被提炼代码只是读取这些变量的值，并不修改它们。
  * 简单的把需要的变量当中参数传递给目标函数
  > 局部变量是个对象，被提炼代码调用了会对该对象造成修改的函数，也可以这样操作。
* 有局部变量-被提炼代码对局部变量进行了赋值
  * 如果变量只在被提炼代码段中使用，可以把它移动到被提炼代码段中。然后一起提炼出去。
  * 如果变量在被提炼代码段之后未再被使用，你只需在目标函数中修改它就可以了。
  * 如果被提炼代码段之后的代码还使用了这个变量，你就需要让目标函数返回该变量改变后的值

### Inline Method (内联函数)

* 现象
  * 内部代码和函数名称同样清晰易读，可以去掉这个函数，直接使用其中的代码
  * 有一群组织不甚合理的函数。可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数
  * 如果使用了太多的间接层，使得系统中所有的函数都似乎只是对另一个函数的简单委托。也可以使用内联手法，找出有用的间接层。同时将那些无用的间接层去除

* 做法 （Idea -> Refactor -> Inline Method）
  * 检查函数，确定它不具有多态性
    > 如果子类继承了这个函数，就不要将此函数内联。因为子类无法覆写一个根本不存在的函数
  * 找出这个函数的所有被调用点
  * 将这个函数的所有被调用点都替换为函数本体
  * 编译，测试
  * 删除该函数的定义

### Inline Temp (内联临时变量)

* 现象
  * 有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法
  > 一般来说，如果某个临时变量被赋予某个函数调用的返回值。一般来说这种变量不会有任何危害，只有在它妨碍了其他重构的时候才需要将它内联化

* 做法 （选中临时变量->Idea->Refactor-> Inline Variable）
  * 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用。
  * 如果这个临时变量没有被声明为final，那就将它声明为final，然后编译
    > 声明成final可以检查临时变量是否真的只被赋值一次。
  * 找到临时变量的所有引用点，将它们替换为"为临时变量赋值"的表达式
  * 每次修改后，编译并测试。
  * 修改完所有引用点之后，删除该临时变量的声明和赋值语句。
  * 编译测试。

### Replace Temp with Query (以查询取代临时变量)
  * 现象
    * 你的程序以一个临时变量保存某一表达式的运算结果
    * 把这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。这样新函数可被其他函数使用

  * 做法 （Extract Method (提炼函数)）
    * 找出只被赋值一次的临时变量
      > 如果某个临时变量被赋值超过一次，考虑使用Split Temporary Variable(分解临时变量)将它分割成多个变量
    * 将该临时变量声明为final
    * 编译
      > 这可确保该临时变量的确只被赋值一次
    * 将"对该临时变量赋值"之语句的等号右侧部分提炼到一个独立函数中
      > 确保提炼出来的函数无任何副作用。也就是函数不能修改任何对象内容。如果它有副作用，就对它进行Separate Query from Modifier()
    * 编译，测试。
    * 在该临时变量身上实施Inline Temp(内联临时变量)
    
  * 例子
```java
    /**
     * 重构之前，有两个临时变量basePrice，discountFactor
     * @return
     */
    double getPrice(){
        int basePrice = quantity*itemPrice;
        double discountFactor;
        if(basePrice > 1000) {
            discountFactor = 0.95;
        } else {
            discountFactor = 0.98;
        }
        return basePrice * discountFactor;
    }

    /**
     * 重构之后
     * @return
     */
    double getPrice_new(){
        return getBasePrice() * getDiscountFactor();
    }
```

### Introduce Explaining Variable (引入解释性变量)
* 现象
  * 有一个复杂的表达式。
  * 将复杂表达式（或其中的一部分）的结果放进一个临时变量。以此变量名称来解释表达式用途
  > 这个方法可以用Extract Method (提炼函数)替换，相较于临时变量，函数可以在对象的整个生命中都有用，并且可以被其他对象使用。
* 做法
  * 声明一个final临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它
  * 将表达式中的"运算结果"这一部分，替换为上述临时变量
  * 编译，测试
  * 重复上述过程。处理表达式的其他部分

* 和Extract Method (提炼函数)比较
  * 一般优先选择Extract Method (提炼函数)
  * 当Extract Method (提炼函数)需要花费大量工作时，比如被处理部分拥有大量局部变量。
  * 使用Introduce Explaining Variable(引入解释性变量)用来理清代码

### Split Temporary Variable(分解临时变量)
* 现象
  * 你的程序某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。
  * 针对每次赋值，创造一个独立、对应的临时变量。以保证临时变量只承担一个责任。
    > 临时变量中某些用途会很自然地导致临时变量被多次赋值。比如"循环变量"和"结果收集变量"。
* 做法
  * 在待分解临时变量的声明及第一次被赋值处，修改其名称。
    > 如果稍后的赋值语句是[i=i+某表达式]形式，就意味着这是个结果收集变量，那么就不要分解它。结果收集变量的作用通常是累加、字符串接合、写入流或者向集合添加元素。
  * 将新的临时变量声明为final。
  * 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让他们引用新的临时变量
  * 在第二次赋值处，重新声明原先那个临时变量
  * 编译，测试。
  * 逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点
    > 在被声明和第一次赋值处修改名称，定位到了变量的开始处。以第二次赋值为界，定位到了变量结束位置。这个方法可以很好的确定范围

### Remove Assignments to Parameters (移除对参数的赋值)
* 现象
  * 代码对一个参数进行赋值,使代码不够清晰
  * 以一个临时变量取代该参数的位置
  > 所谓"对参数赋值"举例来说一个名为foo的对象作为参数传递给某个函数，那么"对参数赋值"意味者改变foo，使它引用另一个对象。但是在对象身上进行其它操作是没有问题的。
* 做法
  * 建立一个临时变量，把待处理的参数值赋予它。
  * 以"对参数的赋值"为界，将其后所有对此参数的引用点，全部替换为"对此临时变量的引用"
  * 修改赋值语句，使其改为对新建之临时变量赋值
  * 编译，测试

### Replace Method with Method Object(以函数对象取代函数)
* 现象
  * 你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method (提炼函数)。
  * 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数
   > 局部变量的存在会增加函数分解难度。可以使用Replace Temp with Query（以查询取代临时变量）帮助减少局部变量。当面对复杂的，局部变量比较多的函数时可以尝试使用本方法将原本的大函数拆解变短
* 做法
  * 建立一个新类，根据待处理函数的用途，为这个类命名
  * 在新类中建立一个final字段。用以保存原先大型函数所在的对象。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存
  * 在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数。
  * 在新类中建立一个computer（）函数
  * 将原函数的代码复制到computer()函数中。如果需要调用源对象的任何函数，请通过源对象字段调用
  > 去掉迁移过来的函数中的临时变量的声明
  * 编译
  * 将旧函数的函数本体替换为这样一条语句："创建上述新类的一个新对象，而后调用其中的computer()函数"
  > 经过上面的操作之后，所有局部变量都成了字段。这时可以任意分解这个大函数，不必传递任何参数

* 例子
```java
class Account {
  /**
   *
   */
  int gamma(int inputVal, int quantity, int yearToDate) {
    int importantValue1 = (inputVal * quantity) + delta();
    int importantValue2 = (inputVal * yearToDate) + 100;
    if (yearToDate - importantValue1 > 100) {
      importantValue2 -= 20;
    }
    int importantValue3 = importantValue2 * 7;
    return importantValue3 - 2 * importantValue1;
  }

  /**
   * 重构方法
   * 新建一个类
   * 新类中新建一个字段保存源类的引用。然后针对原函数所有的参数和临时变量建立对应的属性
   * 在新类中创建一个构造函数，接收源对象，以及原函数的所有参数
   * 将原函数复制到新类中的computer中，去掉函数中临时变量的声明
   * 替换原函数代码为"创建新类，调用其中的方法"
   * @return
   */
  int gamma_new(int inputVal, int quantity, int yearToDate) {
    Gamma gamma = new Gamma(this, inputVal, quantity, yearToDate);
    return gamma.compute();
  }
}    

```

### Substitute Algorithm(替换算法)
* 现象
  * 把某个算法替换为另一个更清晰的算法

## 总结
* 对于方法的整理，最常用的就是Extract Method (提炼函数)。为了更好的进行Extract Method (提炼函数)。我们需要对临时变量进行处理
* 如果临时变量担当了过多的职责，表现为多次赋值
  * Split Temporary Variable(分解临时变量):使临时变量职责更单一，也更容易理清楚代码逻辑
* 如果代码不容易读
  * Introduce Explaining Variable (引入解释性变量):通过将复杂表达式的结果赋值给一个更有意义的临时变量增加代码的可读性
  * Replace Temp with Query (以查询取代临时变量):把复杂的表达式抽取成一个独立的方法，使用函数名称解释函数意图
  * Inline Method (内联函数),Inline Temp (内联临时变量):本就很清晰易读的表达式，可以去除临时变量和函数，直接使用表达式本体
  * Remove Assignments to Parameters (移除对参数的赋值): 入参只表示"被传递进来的东西"。这样的代码会更清晰
* 如果临时变量很多，很杂乱，不能简答的实行Extract Method (提炼函数)
  * Replace Method with Method Object(以函数对象取代函数)：引入一个新的对象，将临时变量转变为全局变量。方便后续的Extract Method (提炼函数)